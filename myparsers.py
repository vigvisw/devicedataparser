# -*- coding: utf-8 -*-
"""myparsers.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rsXQTGnQLr3ugIKk02X_g71b1v-Hu0ms
"""
import re
import numpy as np
import pandas as pd

# define your parsing functions 
class MyParsers:
  '''A container class for housing all the parsing functions'''
  
  # define the parsing functions
  def parse_banner_batsize_hl(spec_value):
    '''A function for parsing the batsize_hl

       Takes in str '3800' and returns the np.floats64 3800
    '''
    return {'batsize':np.float64(spec_value)}


  def parse_banner_displayres_hl(spec_value):
    '''A function for parsing the displayres_hl

       Takes in str '1280x1920 pixels' and returns two np.float64's for the length and height of the screen
    '''
    res_pattern = re.compile('(\d+)x(\d+)')
    return_val =  re.findall(res_pattern, spec_value)
    feature_names = ['displayres_len', 'displayres_height']
    if not return_val:
      return {'displayres_len':np.NaN, 'displayres_height':np.NaN}
    else:
      return  {name:np.float64(i) for name, i  in zip(feature_names, return_val[0])}


  def parse_banner_ramsize_hl(spec_value):
      '''A function for parsing the ramsize_hl

         Takes in str '2' and returns the np.float64 2
      '''
      return {'ramsize':np.float64(spec_value)}


  def parse_banner_displaysize_hl(spec_value):
      '''A function for parsing the displaysize_hl

         Takes in str '6.0"' and returns np.float64 6.0
      '''
      disp_size_pattern = re.compile('(^\d+\.?\d*)\s?"')
      return_val = re.findall(disp_size_pattern, spec_value)
      if not return_val:
        return {'displaysize':np.NaN}
      else:
        return {'displaysize':np.float64(return_val[0])}


  def parse_body_weight(spec_value):
    '''A function for parsing body_weight in devices_data
       Takes in string '165 g ((9.17 oz))' and returns weight in gm as np.float64
    '''
    weight_pattern = re.compile('(\d+\.?\d?)\s?(?:g|gm|gram|grms|grams)')
    weight = re.findall(weight_pattern, spec_value)
    if not weight:
      return {'weight':np.NaN}
    else:
      feature_value = np.float64(weight[0])    
      return {'weight':feature_value}


  # examples of launch_status
  # 1. Available. Released 2018, July
  # 2. Coming soon. Exp. release 2019, Q1
  # 3. Cancelled
  def parse_launch_status(spec_value):
    '''A function for parsing the launch_status

       Returns str 'Available' or 'Coming soon' or 'Cancelled'

    '''
    status_patten = re.compile('(Available|Coming\s?soon|Cancelled|Discontinued).*')
    status = re.findall(status_patten, spec_value)
    if not status:
      return {'launch_status':np.NaN}
    else:
      return {'launch_status':status[0]}


  def parse_launch_announced(spec_value):
    '''A function for parsing the release date of a phone

       Returns a pandas.Timestamp object
    '''
    year_month_pattern = re.compile('\d{4}[\s,.]*(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|\
                                    Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|\
                                    Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)')
    year_only_pattern = re.compile('\d{4}')

    # finding year, month gets hightest priority
    year_month = re.findall(year_month_pattern, spec_value)

    if not year_month:
      year = re.findall(year_only_pattern, spec_value)
      # if year is also not present then set both month and year to np.NaN
      if not year:
        dt = np.NaN
      else:
        dt = year[0]
    else:
      dt = year_month[0]

    return {'launch_announced':pd.to_datetime(dt)}


  def parse_body_dimensions(spec_value):
    '''A function for parsing the body dimensions

       -Returns the value of each dimension as a np.float64. Returns np.NaN if dimensions not found
       -All dimensions are in mm 
       -Volume is also returned as np.float64
    '''
    dimensions_pattern = re.compile('((?:\d+\.?\d*[\sx]+){3})mm')
    float_pattern = re.compile('\d+\.?\d*')

    dimensions = re.findall(dimensions_pattern, spec_value)
    if not dimensions:
      return {'body_x':np.NaN, 'body_y':np.NaN, 'body_z':np.NaN}
    else:
      # find each of the dimensions
      each_dim = re.findall(float_pattern, dimensions[0])
      x = np.float64(each_dim[0])
      y = np.float64(each_dim[1])
      z = np.float64(each_dim[2])
      volume = x * y * z
      return {'body_x':x, 'body_y':y, 'body_z':z, 'volume_mm3':volume}


  # different types of displays noticed
  # 1. OLED
  # 2. LCD 
  # 3. TFT - variant of LCD
  # 4. IPS - variant of LCD
  # 5. Monochrome|Grayscale
  def parse_display_type(spec_value):
    '''A function for categorizing the display types of devices

       Returns str category 'OLED', 'LCD', 'TFT', 'IPS' or 'MONO'
    '''
    # if this is not a known display type return NaN 
    display_type_category = np.NaN

    if re.compile('.*OLED.*').match(spec_value):
      display_type_category = 'OLED'
    elif re.compile('.*LCD.*').match(spec_value):
      display_type_category = 'LCD'
    elif re.compile('.*TFT.*').match(spec_value):
      display_type_category = 'TFT'
    elif re.compile('.*IPS.*').match(spec_value):
      display_type_category = 'IPS'
    elif re.compile('.*[Mm]onochrome.*|.*[Gg]rayscale.*').match(spec_value):
      display_type_category = 'MONO'
    return {'display_type':spec_value, 'display_type_category':display_type_category}


  # values of battery_talk_talk
  # 1. Up to 4 h 30 min
  # 2. Up to 4 h
  # 3. Up to 7 h 30 min (multimedia)
  # 4. Up to 15 h 20 min (2G) / Up to 6 h (3G)
  def parse_battery_talk_time(spec_value):
    '''A function for parsing a device's talk time

       Returns three pd.TimeDelta objects
       If 3G or 2G talktimes are reported, they get a value, else np.NaN
       If neither 3G nor 2g talktimes are reported then make an attempt to find a generic talktime
    '''
    # output variables
    talk_time_3g_td = np.NaN
    talk_time_2g_td = np.NaN
    talk_time_td = np.NaN


    talk_time_3g_pattern = re.compile('.*Up\sto\s((?:\d+\sh)?(?:\s?\d+\smin)?)\s\(3G\)')
    talk_time_2g_pattern = re.compile('.*Up\sto\s((?:\d+\sh)?(?:\s?\d+\smin)?)\s\(2G\)')
    talk_time_pattern = re.compile('.*Up\sto\s((?:\d+\sh)?(?:\s?\d+\smin)?)')

    talk_time_3g = re.findall(talk_time_3g_pattern, spec_value) 
    talk_time_2g = re.findall(talk_time_2g_pattern, spec_value) 

    if talk_time_3g:
      talk_time_3g_td = pd.to_timedelta(talk_time_3g[0])

    if talk_time_2g:
        talk_time_2g_td = pd.to_timedelta(talk_time_2g[0])

    # if this device has neither 2g or 3g talk time, try finding a generic talktime
    if (not talk_time_3g) and (not talk_time_2g):
      talk_time = re.findall(talk_time_pattern, spec_value)
      if talk_time:
        talk_time_td = pd.to_timedelta(talk_time[0])

    return {'talk_time':talk_time_td, 'talk_time_2g':talk_time_2g_td, 'talk_time_3g':talk_time_3g_td}


  def parse_platform_chipset(spec_value):
    '''A function for parsing the device chipset

       Returns silicon gate width (x nm) as np.float64 along with chipset name
    '''
    gate_width_pattern = re.compile('\((\d+)\snm\)')
    gate_width = re.findall(gate_width_pattern, spec_value)

    if gate_width:
      return {'platform_chipset':spec_value, 'platform_chipset_gate_width':np.float64(gate_width[0])}
    else:
      return {'platform_chipset':spec_value, 'platform_chipset_gate_width':np.NaN}

  def parse_misc_price(spec_value):
    '''A function for parsing the price ofa device
       Returns a np.float64 object corresponding to price in EUR
    '''
    price_pattern = re.compile('(\d+\.?\d?)')
    price = re.findall(price_pattern, spec_value)
    if not price:
      return {'misc_price':np.NaN}
    else:
      return {'misc_price':np.float64(price[0])}
